# Оформление объектно-ориентированной части кода

Перед началом хочу напомнить, что питон - динамически типизированный ЯП - это значит, что все что вы видете в питоне - 
объекты, включая стандартные типы данных - int, float, bool и др., но при этом у него строгая типизация, т.е. нельзя,
как в С++ указать на участок памяти, указать размер и сказать, что это будет конкретный тип данных. Для любого приведения типов
необходимо создавать методы или конструкторы.   

#### 1. Никаких логов внутри какого-либо готового продукта
Доступ к информации по запросу пользователя, он уже сам решает, что с ней делать. Для выдаче ее пользователю создавайте
методы, объекты и пр., на самом деле пара специальных методов уже существует - это \_\_repr\_\_ и \_\_str\_\_

#### 2. Глобальные переменные(константы) модуля, которые могут что-то сломать должны быть константами
Глобальные переменные модуля можно изменять за пределами модуля. Если такие переменные влияют на что-то в самом модуле 
или библеотеке, то может случиться, что угодно. Есть много способов решения этой проблемы, которые я опишу позже

#### 3. Если есть возможнось и необходимость, пользуйтесь ООП, оно не просто так придумано
По принципам ООП уже куча инфы в интернете, гуглится на раз-два, но я некоторые вещи все-таки выделю
##### 3.1 Принцип единственной ответственности
Каждый объект должен выполнять строго только одной действие, предназначенное ему. Т.е. не должно быть никакого колдунства,
вроде того, когда вызываешь ф-ию сортировки списков, а от этого рядом падает ядерная бомба. Данный принцип не просто так
придуман, он упрощает разработку приложений на той хрени, которую вы напишете, улучшает ее читаемость и позволяет удобно
тестировать (да да мы пока этого не делаем, но скоро будем).   
Классический пример нарушения этого принципа - создание объекта-Бога. Создается объект, который делает абсолютно все в
вашем приложении. Пример, предоставленный Женей:) класс, выполняющий сразу 4 различных, несвязанных ф-ий - 
[Объект Бог](https://github.com/ArtemZaZ/Code-Convention/blob/master/examples/godobject.py)   
Если у кого-то получится понять, что там происходит, то мое уважение.   
Если у вас затруднение с пониманием того, как правильно разбивать код по задачам, то подумайте, как бы вы его смогли
протестировать. Если в результате выполнения какого-то действия помимо результата у вас появляются побочные эффекты,
которые не относятся к этому действию: меняются аттрибуты классов, изменяются файлы и т.д., то значит вы что-то делаете
не так и код стоит разбить на еще более атомарные действия, которые можно протестировать.

#### 4. Псевдоприватные поля и методы не такие уж и псевдоприватные  
![Image alt](https://github.com/ArtemZaZ/Code-Convention/blob/master/images/privateVariable.jpg)    
Объекты класса, начинающиеся с двух подчеркиваний - являются приватными, в памяти класса они сохраняются, как 
**\_ИмяКласса\_\_имяПеременной**  
Аналог модификатора protected - является единичное подчеркивание, оно не скрывает переменной от пользователя и дает ее
изменять за пределами классов, но среды разработки сигнализируют о доступе к protected переменной, поэтому стараемся не
трогать в коде protected переменные, т.к. это может привести неизвестно к чему, а еще - это нарушение инкапсуляции

#### 5. Несмотря на то, что переменная является приватной, еще можно подгадить
Т.к. при объявлении приватной переменной класс просто меняет ее имя, то вакантное место на имя приватной переменной
остается 
![Image alt](https://github.com/ArtemZaZ/Code-Convention/blob/master/images/privateVariable2.jpg)    
Когда создалась переменная с таким же именем, непонятно также, что произойдет внутри класса. Поэтому так делать не надо,
а еще лучше запрещать создавать объекты в классе(хотя бы с таким же именем) за пределами класса, через \_\_setattr\_\_

#### 5. Проверка на принадлежность к конкретному объекту
Вот так правильно:
```python
class Box:
    def __init__(self):
        self.__boxElements = [] 
    
    def pack(self, boxElement):
        if not isinstance(int):
            raise TypeError("box element must be int type")
        else:
            self.__boxElements.append(boxElement)
            
box = Box()
box.pack(1)
```
Если не делать банальную проверку параметра на принадлежность к какому-то типу/классу/вызываемому объекту
то опять не понятно, что произойдет. Это условие может быть нарушено, если необходимо быстродействие при вызове
конкретной ф-ии, в таком случае, хорошо бы сделать все необъодимое, чтобы не перепутать параметр, подробнее в вики

#### 6. Пространство имен - это хорошо
Если в модуле присутствуют очень много различных перечислений, рекомендуется завернуть их в Enum, именованый кортеж
или др. таким образом, тем более, будет удобнее работать с самими перечислениями
```python
from enum import Enum


class VideoFormat(Enum):
    JPEG = 0
    H264 = 1
    H265 = 2
```
А еще это один из способов сделать неизменяемые переменные см. пункт 2


