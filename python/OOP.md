# Оформление объектно-ориентированной части кода

Перед началом хочу напомнить, что питон - динамически типизированный ЯП - это значит, что все что вы видете в питоне - 
объекты, включая стандартные типы данных - int, float, bool и др., но при этом у него строгая типизация, т.е. нельзя,
как в С++ указать на участок памяти, указать размер и сказать, что это будет конкретный тип данных. Для любого приведения типов
необходимо создавать методы или конструкторы.   

#### 1. Никаких логов внутри какого-либо готового продукта
Доступ к информации по запросу пользователя, он уже сам решает, что с ней делать. Для выдаче ее пользователю создавайте
методы, объекты и пр., на самом деле пара специальных методов уже существует - это \_\_repr\_\_ и \_\_str\_\_

#### 2. Глобальные переменные(константы) модуля, которые могут что-то сломать должны быть константами
Глобальные переменные модуля можно изменять за пределами модуля. Если такие переменные влияют на что-то в самом модуле 
или библеотеке, то может случиться, что угодно. Есть много способов решения этой проблемы, которые я опишу позже

#### 3. Если есть возможнось и необходимость, пользуйтесь ООП, оно не просто так придумано
#### 4. Псевдоприватные поля и методы не такие уж и псевдоприватные  
![Image alt](https://github.com/ArtemZaZ/Code-Convention/blob/master/images/privateVariable.jpg)    
Объекты класса, начинающиеся с двух подчеркиваний - являются приватными, в памяти класса они сохраняются, как 
**\_ИмяКласса\_\_имяПеременной**  
Аналог модификатора protected - является единичное подчеркивание, оно не скрывает переменной от пользователя и дает ее
изменять за пределами классов, но среды разработки сигнализируют о доступе к protected переменной, поэтому стараемся не
трогать в коде protected переменные, т.к. это может привести неизвестно к чему, а еще - это нарушение инкапсуляции

#### 5. Несмотря на то, что переменная является приватной, еще можно подгадить
Т.к. при объявлении приватной переменной класс просто меняет ее имя, то вакантное место на имя приватной переменной
остается 
![Image alt](https://github.com/ArtemZaZ/Code-Convention/blob/master/images/privateVariable2.jpg)    
Когда создалась переменная с таким же именем, непонятно также, что произойдет внутри класса. Поэтому так делать не надо,
а еще лучше запрещать создавать объекты в классе(хотя бы с таким же именем) за пределами класса, через \_\_setattr\_\_

#### 5. Проверка на принадлежность к конкретному объекту
Вот так правильно:
```python
class Box:
    def __init__(self):
        self.__boxElements = [] 
    
    def pack(self, boxElement):
        if not isinstance(int):
            raise TypeError("box element must be int type")
        else:
            self.__boxElements.append(boxElement)
            
box = Box()
box.pack(1)
```
Если не делать банальную проверку параметра на принадлежность к какому-то типу/классу/вызываемому объекту
то опять не понятно, что произойдет. Это условие может быть нарушено, если необходимо быстродействие при вызове
конкретной ф-ии, в таком случае, хорошо бы сделать все необъодимое, чтобы не перепутать параметр, подробнее в вики

#### 6. Пространство имен - это хорошо
Если в модуле присутствуют очень много различных перечислений, рекомендуется завернуть их в Enum, именованый кортеж
или др. таким образом, тем более, будет удобнее работать с самими перечислениями
```python
from enum import Enum


class VideoFormat(Enum):
    JPEG = 0
    H264 = 1
    H265 = 2
```
А еще это один из способов сделать неизменяемые переменные см. пункт 2


